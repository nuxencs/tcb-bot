// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: query.sql

package db

import (
	"context"
)

const insertChapter = `-- name: InsertChapter :exec
INSERT INTO collected_chapters (releaseTitle, releaseLink, mangaTitle, chapterNumber, chapterTitle, releaseTime)
VALUES ($1, $2, $3, $4, $5, $6)
ON CONFLICT(releaseTitle) DO UPDATE
    SET releaseLink   = excluded.releaseLink,
        mangaTitle    = excluded.mangaTitle,
        chapterNumber = excluded.chapterNumber,
        chapterTitle  = excluded.chapterTitle,
        releaseTime   = excluded.releaseTime
`

type InsertChapterParams struct {
	Releasetitle  string
	Releaselink   string
	Mangatitle    string
	Chapternumber string
	Chaptertitle  string
	Releasetime   string
}

func (q *Queries) InsertChapter(ctx context.Context, arg InsertChapterParams) error {
	_, err := q.db.ExecContext(ctx, insertChapter,
		arg.Releasetitle,
		arg.Releaselink,
		arg.Mangatitle,
		arg.Chapternumber,
		arg.Chaptertitle,
		arg.Releasetime,
	)
	return err
}

const listChapters = `-- name: ListChapters :many
SELECT releasetitle, releaselink, mangatitle, chapternumber, chaptertitle, releasetime FROM collected_chapters
ORDER BY releaseTitle
`

func (q *Queries) ListChapters(ctx context.Context) ([]CollectedChapter, error) {
	rows, err := q.db.QueryContext(ctx, listChapters)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CollectedChapter
	for rows.Next() {
		var i CollectedChapter
		if err := rows.Scan(
			&i.Releasetitle,
			&i.Releaselink,
			&i.Mangatitle,
			&i.Chapternumber,
			&i.Chaptertitle,
			&i.Releasetime,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
